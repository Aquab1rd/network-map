<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Alongside Ministries — Map (Manual GMaps + Clusters + Edges + Filters)</title>

  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    :root { --bg:#0f1115; --panel:#151922; --ink:#e8ebf2; --muted:#9aa3b2; --accent:#3aa0ff; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--ink); font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap { max-width:1200px; margin:0 auto; padding:20px; }
    h1 { font-size:20px; margin:4px 0 8px; font-weight:700; }
    .hint { color:var(--muted); font-size:12px; margin:0 0 12px; }
    .grid { display:grid; grid-template-columns: 1fr 380px; gap:16px; }
    .card { background:var(--panel); border:1px solid #202634; border-radius:12px; padding:12px; }
    #map { height:520px; border-radius:10px; overflow:hidden; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .controls label { display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--muted); }
    .row { display:flex; gap:12px; align-items:flex-end; flex-wrap:wrap; }
    select, input[type="text"], button { background:#0c0f16; color:var(--ink); border:1px solid #273043; border-radius:8px; padding:8px 10px; min-width:160px;}
    button { cursor:pointer; }
    .legend { display:flex; flex-wrap:wrap; gap:10px 16px; margin:8px 0 4px; }
    .chip { display:inline-flex; align-items:center; gap:8px; font-size:12px; color:var(--muted); }
    .chip img { width:18px; height:18px; display:inline-block; border-radius:4px; background:#0c0f16; border:1px solid #273043; }
    .edge-legend { display:flex; flex-wrap:wrap; gap:14px; margin-top:8px; font-size:12px; color:var(--muted); }
    .edge-legend .line { width:30px; height:0; border-top-width:4px; border-top-style:solid; border-radius:2px; display:inline-block; }
    .relChecks { display:flex; gap:10px 16px; flex-wrap:wrap; padding:8px; background:#0c0f16; border:1px solid #273043; border-radius:10px; }
    .relChecks label { flex-direction:row; align-items:center; gap:8px; margin:0; }
    .details { white-space:pre-wrap; }
    .cluster-list { margin-top:10px; padding:10px; background:#0c0f16; border:1px solid #273043; border-radius:10px; max-height:220px; overflow:auto; }
    .cluster-list h4 { margin:0 0 8px; font-size:13px; color:var(--muted); }
    .cluster-item { padding:6px 8px; border-radius:8px; display:flex; justify-content:space-between; align-items:center; gap:8px; border:1px solid #202634; margin-bottom:6px; cursor:pointer; }
    .cluster-item:hover { background:#121724; }
    .cluster-tags { font-size:12px; color:var(--muted); }
    a { color:var(--accent); text-decoration:none; }
    a:hover { text-decoration:underline; }
    .error { color:#ff7b7b; font-weight:600; }
    @media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Alongside Ministries — Interactive 2D Map</h1>
    <div id="status" class="hint">Loading data…</div>

    <div class="controls card">
      <div class="row">
        <label>Type
          <select id="typeFilter"><option>All</option></select>
        </label>
        <label>Tag
          <select id="tagFilter"><option>Any</option></select>
        </label>
        <label>Degree
          <select id="degreeFilter">
            <option value="All">All</option>
            <option value="1">First (direct to Alongside)</option>
            <option value="2">Second (indirect)</option>
          </select>
        </label>
        <label>Search
          <input id="searchBox" type="text" placeholder="Type a name…"/>
        </label>
        <label style="display:flex;align-items:center;gap:8px;">
          <input id="toggleLines" type="checkbox" checked/> Show lines
        </label>
        <button id="clearSel">Clear selection</button>
      </div>
      <div style="margin-top:10px;">
        <div style="color:var(--muted); font-size:12px; margin:6px 0 6px;">Relationship types</div>
        <div id="relChecks" class="relChecks"></div>
      </div>
    </div>

    <div class="legend card" id="legend"></div>
    <div class="edge-legend" id="edgeLegend"></div>

    <div class="grid">
      <div class="card" style="grid-column: 1 / -1;">
        <div id="map"></div>
      </div>
      <div class="card details" id="details">(Click a pin or a line to see details)</div>
      <div class="card" id="clusterPanel" style="display:none;">
        <div class="cluster-list" id="clusterList"></div>
      </div>
    </div>
  </div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
  (async function(){
    // === LIVE SHEETS + TOKEN ===
    const NODES_CSV_URL = "https://docs.google.com/spreadsheets/d/1MSwF46BkDjRhOdHd4Pw0ArCVgvdcgDACWvyswFq8XI4/gviz/tq?tqx=out:csv&sheet=Nodes";
    const EDGES_CSV_URL = "https://docs.google.com/spreadsheets/d/1eQrmiVA4wxf6J79SZkyhZb-vEAyX3yxfapen113MSrA/gviz/tq?tqx=out:csv&sheet=Edges";
    const MAPBOX_TOKEN  = "pk.eyJ1IjoiYXF1YWIxcmQiLCJhIjoiY21ndjl5Y2RzMGN2azJsc2J4d3d2N2tyeSJ9.JApvZZEs_kiwNl4Y9-aRaQ";

    // ZOOM CONSTANTS
    const Z_NODE_FOCUS = 11; // must be > clusterMaxZoom to ensure de-cluster

    // UI refs
    const statusEl = document.getElementById('status');
    const typeSel  = document.getElementById('typeFilter');
    const tagSel   = document.getElementById('tagFilter');
    const degreeSel= document.getElementById('degreeFilter');
    const search   = document.getElementById('searchBox');
    const clearSel = document.getElementById('clearSel');
    const toggleLines = document.getElementById('toggleLines');
    const legend   = document.getElementById('legend');
    const edgeLegend = document.getElementById('edgeLegend');
    const relChecks = document.getElementById('relChecks');
    const details  = document.getElementById('details');
    const clusterPanel = document.getElementById('clusterPanel');
    const clusterList = document.getElementById('clusterList');

    const setStatus = (msg, isError=false)=>{ statusEl.innerHTML = isError ? `<span class="error">${msg}</span>` : msg; };

    // --- CSV loader ---
    async function loadCSV(url){
      const r = await fetch(url, {cache:"no-store"});
      if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
      const text = await r.text();
      return Papa.parse(text, {header:true, skipEmptyLines:true}).data || [];
    }
    const normKey = k => String(k||'').replace(/^\ufeff/,'').trim().toLowerCase();
    const toNum = v => { if(v==null) return NaN; const n=Number(String(v).trim().replace(',','.')); return Number.isFinite(n)? n: NaN; };
    const findKey = (headers, aliases)=>{ const H=headers.map(normKey); for(const a of aliases){ const i=H.indexOf(a); if(i!=-1) return headers[i]; } return null; };

    // Load
    let rawNodes, rawEdges;
    try { [rawNodes, rawEdges] = await Promise.all([loadCSV(NODES_CSV_URL), loadCSV(EDGES_CSV_URL)]); }
    catch(e){ setStatus(`Couldn’t load Google Sheets. Check sharing/tab names.<br>${e.message}`, true); return; }

    // Nodes
    const nodeHeaders = Object.keys(rawNodes[0] || {});
    const latKey = findKey(nodeHeaders, ["lat","latitude","y","coord_lat","latitud"]);
    const lonKey = findKey(nodeHeaders, ["lon","lng","long","longitude","x","coord_lon","longitud"]);
    const pubKey = findKey(nodeHeaders, ["public","visible","publish","is_public"]);
    const degKey = findKey(nodeHeaders, ["degree","deg","tier"]);
    const gmapsKey = findKey(nodeHeaders, ["gmaps","gmaps_link","googlemaps"]);

    function normalizeDegree(v){
      const s=String(v??"").trim().toLowerCase();
      if (s==="1" || s==="first" || s==="direct") return "1";
      if (s==="2" || s==="second" || s==="indirect") return "2";
      return "1"; // default to first if unset
    }

    // manual-only gmaps (no auto from lat/lon)
    function readManualGMaps(row){
      if (!gmapsKey) return "";
      const val = String(row[gmapsKey] ?? "").trim();
      return val; // may be "" → hidden
    }

    const nodes = rawNodes.map(row => {
      const lat = latKey ? toNum(row[latKey]) : NaN;
      const lon = lonKey ? toNum(row[lonKey]) : NaN;
      let vis = true;
      if (pubKey){ const raw = String(row[pubKey] ?? "").trim().toUpperCase(); vis = (raw===""||raw==="TRUE"||raw==="YES"||raw==="1"); }
      const degree = normalizeDegree(degKey ? row[degKey] : "");
      const id = String(row.id ?? row.ID ?? row.Id ?? "").trim() || String(row.name ?? "").trim();
      const name = String(row.name ?? row.Name ?? "").trim();
      return {
        id, name,
        type: String(row.type ?? row.Type ?? "").trim(),
        city: String(row.city ?? "").trim(),
        country: String(row.country ?? "").trim(),
        lat, lon,
        tags: String(row.tags ?? "").split(/[;,]/).map(t=>t.trim()).filter(Boolean),
        url: row.url ?? "",
        gmaps: readManualGMaps(row), // manual-only link
        public: vis,
        degree
      };
    }).filter(n => n.id && Number.isFinite(n.lat) && Number.isFinite(n.lon) && n.public);
    if (!nodes.length){ setStatus(`No valid nodes. Check lat/lon + 'public' values.`, true); return; }
    const nodeById = new Map(nodes.map(n => [n.id, n]));

    // Adjacency (for indirect B→C text)
    const outAdj = new Map(), inAdj = new Map();
    const addToSet = (map, key, val)=>{ if(!map.has(key)) map.set(key, new Set()); map.get(key).add(val); };

    // Edges
    const edgesRaw = rawEdges.map(e => {
      const s = String(e.source_id ?? e.source ?? "").trim();
      const t = String(e.target_id ?? e.target ?? "").trim();
      const rel = String(e.relationship ?? e.relation ?? "linked").trim();
      const since = String(e.since ?? e.year ?? "").trim();
      const pubRaw = String(e.public ?? "").trim().toUpperCase();
      const isPublic = (pubRaw===""||pubRaw==="TRUE"||pubRaw==="YES"||pubRaw==="1");
      return { source:s, target:t, relationship: rel || "linked", since, public:isPublic };
    }).filter(e => e.public && nodeById.has(e.source) && nodeById.has(e.target) && e.source !== e.target);

    // de-dupe
    const seen = new Set(), uniqEdges=[];
    for (const e of edgesRaw){
      const [a,b] = e.source < e.target ? [e.source,e.target] : [e.target,e.source];
      const key = a+"|"+b+"|"+(e.relationship||"");
      if(!seen.has(key)){ seen.add(key); uniqEdges.push(e); }
    }
    for (const e of uniqEdges){
      addToSet(outAdj, e.source, e.target);
      addToSet(inAdj,  e.target, e.source);
    }

    // Types/colors/shapes
    const types = Array.from(new Set(nodes.map(n => n.type))).sort();
    const allTags = Array.from(new Set(nodes.flatMap(n => n.tags))).sort();
    for (const t of types) typeSel.append(new Option(t, t));
    for (const t of allTags) tagSel.append(new Option(t, t));

    const palette = ["#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f","#edc948","#b07aa1","#ff9da7","#9c755f","#bab0ab",
                     "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"];
    const typeColors = new Map(types.map((t,i)=>[t, palette[i % palette.length]]));
    const SHAPE_BY_TYPE = new Map([["Alongsider","circle"],["Church","square"],["Partner","diamond"],["Supporter","triangle"]]);
    const fallbackShape="circle";

    // Relationship styles + checkboxes
    const REL_STYLE = {
      leads:     { color:"#e15759", width:2.5, label:"Leads" },
      supports:  { color:"#59a14f", width:2.5, label:"Supports" },
      partners:  { color:"#4e79a7", width:2.5, label:"Partners" },
      linked:    { color:"#9aa3b2", width:2.0, label:"Linked" }
    };
    const relTypes = Array.from(new Set(uniqEdges.map(e => (e.relationship||"linked").toLowerCase()))).sort();

    const selectedRels = new Set(); // empty => show all
    function addRelCheck(relKey){
      const st = REL_STYLE[relKey] || { color:"#9aa3b2", label: relKey };
      const id = `rel_${relKey}`;
      const wrap = document.createElement("label");
      wrap.innerHTML = `<input type="checkbox" id="${id}"> <span>${st.label}</span>`;
      wrap.style.color = st.color;
      relChecks.appendChild(wrap);
      const cb = wrap.querySelector("input");
      cb.addEventListener("change", ()=>{
        if (cb.checked) selectedRels.add(relKey); else selectedRels.delete(relKey);
        refresh();
      });
    }
    relTypes.forEach(addRelCheck);

    for (const r of relTypes){
      const st = REL_STYLE[r] || REL_STYLE.linked;
      const span = document.createElement("span");
      span.innerHTML = `<span class="line" style="border-top-color:${st.color}"></span> ${st.label || r}`;
      edgeLegend.append(span);
    }

    // Map
    mapboxgl.accessToken = MAPBOX_TOKEN;
    const map = new mapboxgl.Map({
      container:'map', style:'mapbox://styles/mapbox/light-v11',
      center:[24,56], zoom:3, projection:'equalEarth'
    });
    map.addControl(new mapboxgl.NavigationControl());

    // Icon drawing + registration
    function makeIconCanvas(shape, fill, size=48, stroke="#111"){
      const c=document.createElement("canvas"); c.width=c.height=size;
      const ctx=c.getContext("2d");
      ctx.clearRect(0,0,size,size);
      ctx.lineWidth=Math.max(2,size*0.05);
      ctx.strokeStyle=stroke; ctx.fillStyle=fill;
      const r=size*0.33, cx=size/2, cy=size/2;
      ctx.beginPath();
      if(shape==="circle"){ ctx.arc(cx,cy,r,0,Math.PI*2); }
      else if(shape==="square"){ const s=r*1.6; ctx.rect(cx-s/2,cy-s/2,s,s); }
      else if(shape==="diamond"){ const s=r*1.8; ctx.moveTo(cx,cy-s/2); ctx.lineTo(cx+s/2,cy); ctx.lineTo(cx,cy+s/2); ctx.lineTo(cx-s/2,cy); ctx.closePath(); }
      else if(shape==="triangle"){ const s=r*2.0, h=s*Math.sqrt(3)/2; ctx.moveTo(cx,cy-h/2); ctx.lineTo(cx-s/2,cy+h/2); ctx.lineTo(cx+s/2,cy+h/2); ctx.closePath(); }
      else { ctx.arc(cx,cy,r,0,Math.PI*2); }
      ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.fillStyle="rgba(255,255,255,0.95)"; ctx.arc(cx,cy,size*0.035,0,Math.PI*2); ctx.fill();
      return c;
    }
    function addCanvasAsImage(map, id, canvas){
      const ctx=canvas.getContext('2d'); const {width,height}=canvas; const img=ctx.getImageData(0,0,width,height);
      if(map.hasImage(id)) map.removeImage(id);
      map.addImage(id, img, { pixelRatio:1 });
    }
    function legendSwatch(shape,color){
      const c=makeIconCanvas(shape,color,22); const img=document.createElement("img"); img.src=c.toDataURL("image/png"); return img;
    }

    function passesNodeFilters(n){
      const typeOk = (typeSel.value==="All"||n.type===typeSel.value);
      const tagOk  = (tagSel.value==="Any"||n.tags.includes(tagSel.value));
      const degOk  = (degreeSel.value==="All"||n.degree===degreeSel.value);
      return typeOk && tagOk && degOk;
    }
    function relAllowed(rel){
      if (selectedRels.size === 0) return true;
      return selectedRels.has(rel);
    }

    function nodeFeatures(list, iconNameForType){
      return list.map(n => ({
        type:"Feature",
        geometry:{ type:"Point", coordinates:[n.lon,n.lat] },
        properties:{ id:n.id, name:n.name, type:n.type, icon: iconNameForType.get(n.type) || "fallback" }
      }));
    }

    let selectedNodeId = null;
    let selectedEdgeKey = null;
    function edgeKey(e){
      const a = e.source < e.target ? e.source : e.target;
      const b = e.source < e.target ? e.target : e.source;
      return `${a}|${b}|${(e.relationship||"linked").toLowerCase()}`;
    }

    function edgeFeatures(allowedIds){
      const feats=[];
      for(const e of uniqEdges){
        const rel=(e.relationship||"linked").toLowerCase();
        if(!relAllowed(rel)) continue;
        if(!allowedIds.has(e.source)||!allowedIds.has(e.target)) continue;
        const a=nodeById.get(e.source), b=nodeById.get(e.target);
        const st=REL_STYLE[rel] || REL_STYLE.linked;
        const isNodeHi = selectedNodeId && (e.source===selectedNodeId || e.target===selectedNodeId);
        const isEdgeHi = selectedEdgeKey && selectedEdgeKey===edgeKey(e);
        const hi = isNodeHi || isEdgeHi;
        feats.push({
          type:"Feature",
          geometry:{ type:"LineString", coordinates:[[a.lon,a.lat],[b.lon,b.lat]] },
          properties:{
            source:e.source, target:e.target, relationship:rel, since:e.since||"",
            color: st.color, width: hi ? st.width+1.5 : st.width, opacity: hi ? 0.9 : 0.45,
            key: edgeKey(e)
          }
        });
      }
      return feats;
    }

    function nodeDetailsHTML(n){
      const lines = [];
      lines.push(`<b>${n.name}</b> — <i>${n.type}</i>`);
      lines.push(`${n.city ? n.city + ", " : ""}${n.country || ""}`);
      if (n.tags?.length) lines.push(`Tags: ${n.tags.join(", ")}`);
      if (n.url)   lines.push(`<a href="${n.url}" target="_blank" rel="noopener">Website</a>`);
      if (n.gmaps) lines.push(`<a href="${n.gmaps}" target="_blank" rel="noopener">Open in Google Maps</a>`);
      lines.push(`Degree: ${n.degree==="1"?"First (direct)":"Second (indirect)"}`);
      return lines.join("\n");
    }

    function edgeDetailsHTML(f){
      const a = nodeById.get(f.properties.source);
      const b = nodeById.get(f.properties.target);
      const rel = f.properties.relationship;
      const since = f.properties.since;
      const label = REL_STYLE[rel]?.label || rel;

      // Indirects: A→B and B→C
      const second = [];
      const bn = b?.id;
      const outs = bn ? Array.from(outAdj.get(bn) || []) : [];
      for (const cId of outs){
        if (cId === a?.id) continue;
        const c = nodeById.get(cId);
        if (c) second.push(`• ${b?.name} → ${c.name}`);
      }
      const extra = second.length ? `\n\nAlso connected:\n${second.join("\n")}` : "";

      return `<b>${a?.name || f.properties.source}</b> — ${label} — <b>${b?.name || f.properties.target}</b>${since?` (since ${since})`:""}${extra}`;
    }

    // Cluster sidebar helpers
    function showClusterList(title, list){
      clusterPanel.style.display = "block";
      const items = list.map(n => `
        <div class="cluster-item" data-id="${n.id}">
          <div>
            <div><b>${n.name}</b> — <i>${n.type}</i></div>
            <div class="cluster-tags">${n.city ? n.city + ", " : ""}${n.country || ""}${n.tags?.length?` · ${n.tags.join(", ")}`:""}</div>
          </div>
          <div>↗</div>
        </div>
      `).join("");
      clusterList.innerHTML = `<h4>${title}</h4>${items || "(No items)"}`;
      clusterList.querySelectorAll(".cluster-item").forEach(el=>{
        el.addEventListener("click", ()=>{
          const id = el.getAttribute("data-id");
          const n = nodeById.get(id);
          if (!n) return;

          // First zoom beyond cluster threshold so the pin exists,
          // then select/highlight it.
          const once = () => {
            map.off('moveend', once);
            selectNode(id, true);
          };
          map.on('moveend', once);
          map.easeTo({ center:[n.lon, n.lat], zoom: Z_NODE_FOCUS, duration: 600 });
        });
      });
    }
    function hideClusterList(){ clusterPanel.style.display="none"; clusterList.innerHTML=""; }

    map.on('load', () => {
      // keep it 2D
      map.setPitch(0); map.setBearing(0); map.dragRotate.disable(); map.touchZoomRotate.disableRotation();

      // Register icons + legend
      if(!map.hasImage("fallback")) addCanvasAsImage(map,"fallback",makeIconCanvas("circle","#999",48));
      const iconNameForType = new Map();
      for (const t of types){
        const shape = SHAPE_BY_TYPE.get(t) || fallbackShape;
        const color = typeColors.get(t) || "#999";
        const name = `marker-${t.replace(/\s+/g,'_')}`;
        addCanvasAsImage(map, name, makeIconCanvas(shape, color, 48));
        iconNameForType.set(t, name);

        const chip=document.createElement("div"); chip.className="chip";
        chip.append(legendSwatch(shape,color));
        const lbl=document.createElement("span"); lbl.textContent=t||"(Uncategorized)";
        chip.append(lbl); legend.append(chip);
      }

      // Initial filtered set
      const visibleNodes = nodes.filter(passesNodeFilters);
      const allowedIds = new Set(visibleNodes.map(n=>n.id));

      // EDGES
      map.addSource("edges", { type:"geojson", data:{ type:"FeatureCollection", features: edgeFeatures(allowedIds) }});
      map.addLayer({
        id:"edges",
        type:"line",
        source:"edges",
        paint:{ "line-color":["get","color"], "line-width":["get","width"], "line-opacity":["get","opacity"] },
        layout:{ "line-cap":"round", "line-join":"round" }
      });
      // fat invisible hit layer for easy clicking
      map.addLayer({
        id:"edges-hit",
        type:"line",
        source:"edges",
        paint:{ "line-color":"#000", "line-width":[ "+", ["get","width"], 8 ], "line-opacity":0 },
        layout:{ "line-cap":"round", "line-join":"round" }
      });

      // NODES with clustering
      const initialNodeFeatures = nodeFeatures(visibleNodes, iconNameForType);
      map.addSource("nodes", {
        type:"geojson",
        data:{ type:"FeatureCollection", features: initialNodeFeatures },
        cluster:true, clusterRadius:50, clusterMaxZoom:10
      });

      // Clusters
      map.addLayer({
        id: "clusters",
        type: "circle",
        source: "nodes",
        filter: ["has","point_count"],
        paint: {
          "circle-color": "#273043",
          "circle-stroke-color": "#3a4863",
          "circle-stroke-width": 1.5,
          "circle-radius": ["step", ["get","point_count"], 14, 10, 18, 25, 24, 50, 30]
        }
      });
      map.addLayer({
        id: "cluster-count",
        type: "symbol",
        source: "nodes",
        filter: ["has","point_count"],
        layout: {
          "text-field": ["get","point_count_abbreviated"],
          "text-font": ["Open Sans Semibold","Arial Unicode MS Bold"],
          "text-size": 12
        },
        paint: { "text-color": "#e8ebf2" }
      });

      // Unclustered markers (use custom icons)
      map.addLayer({
        id:"nodes",
        type:"symbol",
        source:"nodes",
        filter: ["!", ["has","point_count"]],
        layout:{ "icon-image":["get","icon"], "icon-size":0.7, "icon-allow-overlap":true }
      });

      function fitTo(features){
        if(!features.length) return;
        const b=new mapboxgl.LngLatBounds(); features.forEach(f=>b.extend(f.geometry.coordinates));
        map.fitBounds(b, {padding:40, maxZoom:6});
      }
      fitTo(initialNodeFeatures);

      // Refresh with filters / toggles
      function refresh(){
        selectedNodeId=null; selectedEdgeKey=null; hideClusterList();
        const list = nodes.filter(passesNodeFilters);
        const feats = nodeFeatures(list, iconNameForType);
        const ids = new Set(list.map(n=>n.id));

        // nodes (cluster source)
        map.getSource("nodes").setData({ type:"FeatureCollection", features: feats });

        // edges
        if (toggleLines.checked) {
          const edgeFeats = edgeFeatures(ids);
          map.getSource("edges").setData({ type:"FeatureCollection", features: edgeFeats });
          map.setLayoutProperty("edges","visibility","visible");
          map.setLayoutProperty("edges-hit","visibility","visible");
        } else {
          map.getSource("edges").setData({ type:"FeatureCollection", features: [] });
          map.setLayoutProperty("edges","visibility","none");
          map.setLayoutProperty("edges-hit","visibility","none");
        }

        fitTo(feats);
      }

      typeSel.addEventListener("change", refresh);
      tagSel.addEventListener("change", refresh);
      degreeSel.addEventListener("change", refresh);
      toggleLines.addEventListener("change", refresh);

      // Search
      search.addEventListener("input", () => {
        const q = search.value.toLowerCase().trim();
        const hit = nodes.find(n => passesNodeFilters(n) && n.name.toLowerCase().includes(q));
        if (hit) selectNode(hit.id, false);
      });
      clearSel.addEventListener("click", ()=>{ search.value=""; details.textContent="(Click a pin or a line to see details)"; refresh(); });

      // Node select (also used after cluster-list zoom)
      function selectNode(id, keepClusterOpen=false){
        selectedNodeId = id; selectedEdgeKey=null;
        const n = nodeById.get(id); if(!n) return;
        details.innerHTML = nodeDetailsHTML(n);
        map.flyTo({center:[n.lon,n.lat], zoom: Z_NODE_FOCUS}); // ensure unclustered

        const list = nodes.filter(passesNodeFilters);
        const ids = new Set(list.map(x=>x.id));
        const edgeFeats = edgeFeatures(ids);
        map.getSource("edges").setData({ type:"FeatureCollection", features: edgeFeats });

        if (!keepClusterOpen) hideClusterList();
      }

      map.on("click","nodes",(e)=>{
        const f=e.features?.[0]; if(!f) return;
        selectNode(f.properties.id);
      });

      // Cluster click → show list and zoom; list item click zooms + selects node
      map.on("click","clusters", (e) => {
        const features = map.queryRenderedFeatures(e.point, { layers: ["clusters"] });
        const clusterId = features[0]?.properties?.cluster_id;
        if (clusterId == null) return;

        map.getSource("nodes").getClusterLeaves(clusterId, 200, 0, (err, leaves) => {
          if (err || !leaves) return;
          const items = leaves.map(l => nodeById.get(l.properties.id)).filter(Boolean);
          showClusterList(`This area has ${items.length} items`, items);
        });

        map.getSource("nodes").getClusterExpansionZoom(clusterId, (err, zoom) => {
          if (err) return;
          // expand a bit, but final zoom happens when list item clicked
          map.easeTo({ center: e.lngLat, zoom: Math.max(zoom, 9) });
        });
      });

      // Clickable edges (with indirect B→C text)
      map.on("click","edges-hit",(e)=>{
        const f=e.features?.[0]; if(!f) return;
        selectedNodeId=null;
        selectedEdgeKey = f.properties.key || null;
        details.innerHTML = edgeDetailsHTML(f);

        const list = nodes.filter(passesNodeFilters);
        const ids = new Set(list.map(x=>x.id));
        const edgeFeats = edgeFeatures(ids);
        map.getSource("edges").setData({ type:"FeatureCollection", features: edgeFeats });
        hideClusterList();
      });

      setStatus(`Loaded <b>${nodes.length}</b> nodes and <b>${uniqEdges.length}</b> edges.`);
    });
  })();
  </script>
</body>
</html>
