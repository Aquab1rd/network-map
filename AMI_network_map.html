<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Alongside Ministries — 2D Map (Shapes + Colors)</title>

  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    :root { --bg:#0f1115; --panel:#151922; --ink:#e8ebf2; --muted:#9aa3b2; --accent:#3aa0ff; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--ink); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
    .wrap { max-width:1200px; margin:0 auto; padding:20px; }
    h1 { font-size:20px; margin:4px 0 8px; font-weight:700; }
    .hint { color:var(--muted); font-size:12px; margin:0 0 12px; }
    .grid { display:grid; grid-template-columns: 1fr 380px; gap:16px; }
    .card { background:var(--panel); border:1px solid #202634; border-radius:12px; padding:12px; }
    #map { height:520px; border-radius:10px; overflow:hidden; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .controls label { display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--muted); }
    select, input[type="text"], button { background:#0c0f16; color:var(--ink); border:1px solid #273043; border-radius:8px; padding:8px 10px; min-width:160px;}
    button { cursor:pointer; }
    .legend { display:flex; flex-wrap:wrap; gap:10px 16px; margin:8px 0 4px; }
    .chip { display:inline-flex; align-items:center; gap:8px; font-size:12px; color:var(--muted); }
    .chip img { width:18px; height:18px; display:inline-block; border-radius:4px; background:#0c0f16; border:1px solid #273043; }
    .details { white-space:pre-wrap; }
    a { color:var(--accent); text-decoration:none; }
    a:hover { text-decoration:underline; }
    .error { color:#ff7b7b; font-weight:600; }
    @media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Alongside Ministries — Interactive 2D Map</h1>
    <div id="status" class="hint">Loading data…</div>

    <div class="controls card">
      <label>Type
        <select id="typeFilter"><option>All</option></select>
      </label>
      <label>Tag
        <select id="tagFilter"><option>Any</option></select>
      </label>
      <label>Search
        <input id="searchBox" type="text" placeholder="Type a name…"/>
      </label>
      <button id="clearSel" style="margin-top:auto;">Clear selection</button>
    </div>

    <div class="legend card" id="legend"></div>

    <div class="grid">
      <div class="card" style="grid-column: 1 / -1;">
        <div id="map"></div>
      </div>
      <div class="card details" id="details">(Click a pin to see details)</div>
    </div>
  </div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
  (async function(){
    // === LIVE SHEETS + TOKEN ===
    const NODES_CSV_URL = "https://docs.google.com/spreadsheets/d/1MSwF46BkDjRhOdHd4Pw0ArCVgvdcgDACWvyswFq8XI4/gviz/tq?tqx=out:csv&sheet=Nodes";
    const EDGES_CSV_URL = "https://docs.google.com/spreadsheets/d/1eQrmiVA4wxf6J79SZkyhZb-vEAyX3yxfapen113MSrA/gviz/tq?tqx=out:csv&sheet=Edges";
    const MAPBOX_TOKEN  = "pk.eyJ1IjoiYXF1YWIxcmQiLCJhIjoiY21ndjl5Y2RzMGN2azJsc2J4d3d2N2tyeSJ9.JApvZZEs_kiwNl4Y9-aRaQ";

    const statusEl = document.getElementById('status');
    const typeSel  = document.getElementById('typeFilter');
    const tagSel   = document.getElementById('tagFilter');
    const search   = document.getElementById('searchBox');
    const clearSel = document.getElementById('clearSel');
    const legend   = document.getElementById('legend');
    const details  = document.getElementById('details');

    function setStatus(msg, isError=false){
      statusEl.innerHTML = isError ? `<span class="error">${msg}</span>` : msg;
    }

    // --- CSV loader ---
    async function loadCSV(url){
      const r = await fetch(url, {cache:"no-store"});
      if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
      const text = await r.text();
      return Papa.parse(text, {header:true, skipEmptyLines:true}).data || [];
    }
    const normKey = k => String(k||'').replace(/^\ufeff/,'').trim().toLowerCase();
    const toNum = v => {
      if (v == null) return NaN;
      const s = String(v).trim().replace(',', '.');
      const n = Number(s);
      return Number.isFinite(n) ? n : NaN;
    };
    function findKey(headers, aliases){
      const H = headers.map(normKey);
      for (const a of aliases){
        const i = H.indexOf(a);
        if (i !== -1) return headers[i];
      }
      return null;
    }

    let rawNodes, rawEdges;
    try {
      [rawNodes, rawEdges] = await Promise.all([loadCSV(NODES_CSV_URL), loadCSV(EDGES_CSV_URL)]);
    } catch (e){
      setStatus(`Couldn’t load Google Sheets. Check sharing and tab names.<br>${e.message}`, true);
      return;
    }

    const nodeHeaders = Object.keys(rawNodes[0] || {});
    const latKey = findKey(nodeHeaders, ["lat","latitude","y","coord_lat","latitud"]);
    const lonKey = findKey(nodeHeaders, ["lon","lng","long","longitude","x","coord_lon","longitud"]);
    const pubKey = findKey(nodeHeaders, ["public","visible","publish","is_public"]);

    const nodes = rawNodes.map(row => {
      const lat = latKey ? toNum(row[latKey]) : NaN;
      const lon = lonKey ? toNum(row[lonKey]) : NaN;
      let vis = true;
      if (pubKey){
        const raw = String(row[pubKey] ?? "").trim().toUpperCase();
        vis = (raw === "" || raw === "TRUE" || raw === "YES" || raw === "1");
      }
      return {
        id: String(row.id ?? row.ID ?? row.Id ?? "").trim() || String(row.name ?? "").trim(),
        name: String(row.name ?? row.Name ?? "").trim(),
        type: String(row.type ?? row.Type ?? "").trim(),
        city: String(row.city ?? "").trim(),
        country: String(row.country ?? "").trim(),
        lat, lon,
        tags: String(row.tags ?? "").split(/[;,]/).map(t=>t.trim()).filter(Boolean),
        url: row.url ?? "",
        public: vis
      };
    }).filter(n => n.id && Number.isFinite(n.lat) && Number.isFinite(n.lon) && n.public);

    if (!nodes.length){
      setStatus(`No valid nodes found. Check lat/lon columns and 'public' values.`, true);
      return;
    }

    // === Types → colors + shapes ===
    const types = Array.from(new Set(nodes.map(n => n.type))).sort();
    const allTags = Array.from(new Set(nodes.flatMap(n => n.tags))).sort();
    for (const t of types) typeSel.append(new Option(t, t));
    for (const t of allTags) tagSel.append(new Option(t, t));

    // Nice palette, deterministic by type index
    const palette = ["#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f","#edc948","#b07aa1","#ff9da7","#9c755f","#bab0ab",
                     "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"];
    const typeColors = new Map(types.map((t,i)=>[t, palette[i % palette.length]]));
    const SHAPE_BY_TYPE = new Map([
      ["Alongsider", "circle"],
      ["Church", "square"],
      ["Partner", "diamond"],
      ["Supporter", "triangle"]
    ]);
    const fallbackShape = "circle";
    const colorFor = n => typeColors.get(n.type) || "#999";
    const shapeFor = n => SHAPE_BY_TYPE.get(n.type) || fallbackShape;

    // === 2D FLAT MAP ===
    mapboxgl.accessToken = MAPBOX_TOKEN;
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v11',
      center: [24,56],
      zoom: 3,
      projection: 'equalEarth'
    });
    map.addControl(new mapboxgl.NavigationControl());

    // --- icon factory: draw colored shapes on canvas and add to map as images ---
    function makeIcon(shape, fill, size=28, stroke="#222"){
      const c = document.createElement("canvas");
      c.width = c.height = size;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,size,size);
      ctx.lineWidth = 2;
      ctx.strokeStyle = stroke;
      ctx.fillStyle = fill;

      const r = size*0.35;
      const cx = size/2, cy = size/2;

      ctx.beginPath();
      if (shape === "circle"){
        ctx.arc(cx, cy, r, 0, Math.PI*2);
      } else if (shape === "square"){
        const s = r*1.5;
        ctx.rect(cx - s/2, cy - s/2, s, s);
      } else if (shape === "diamond"){
        const s = r*1.55;
        ctx.moveTo(cx, cy - s/2);
        ctx.lineTo(cx + s/2, cy);
        ctx.lineTo(cx, cy + s/2);
        ctx.lineTo(cx - s/2, cy);
        ctx.closePath();
      } else if (shape === "triangle"){
        const s = r*1.8;
        const h = s*Math.sqrt(3)/2;
        ctx.moveTo(cx, cy - h/2);
        ctx.lineTo(cx - s/2, cy + h/2);
        ctx.lineTo(cx + s/2, cy + h/2);
        ctx.closePath();
      } else {
        // fallback circle
        ctx.arc(cx, cy, r, 0, Math.PI*2);
      }
      ctx.fill();
      ctx.stroke();
      return c;
    }

    // Prebuild a map of type -> iconName, and also make legend swatches
    const iconNameForType = new Map();
    function legendSwatch(shape, color){
      const c = makeIcon(shape, color, 22);
      const img = document.createElement("img");
      img.src = c.toDataURL("image/png");
      return img;
    }

    map.on('load', () => {
      // force 2D feel (no tilt/rotation)
      map.setPitch(0);
      map.setBearing(0);
      map.dragRotate.disable();
      map.touchZoomRotate.disableRotation();

      // Register one icon per type (shape+color combo)
      for (const t of types){
        const shape = SHAPE_BY_TYPE.get(t) || fallbackShape;
        const color = typeColors.get(t) || "#999";
        const icon = makeIcon(shape, color, 28);
        const iconName = `marker-${t.replace(/\s+/g,'_')}`;
        if (!map.hasImage(iconName)) {
          map.addImage(iconName, icon, { pixelRatio: 2 });
        }
        iconNameForType.set(t, iconName);

        // Legend chip
        const chip = document.createElement("div"); chip.className="chip";
        chip.append(legendSwatch(shape, color));
        const label = document.createElement("span"); label.textContent = t;
        chip.append(label);
        legend.append(chip);
      }

      // GeoJSON with per-feature icon name
      const features = nodes.map(n => ({
        type: "Feature",
        geometry: { type: "Point", coordinates: [n.lon, n.lat] },
        properties: {
          id: n.id,
          name: n.name,
          type: n.type,
          icon: iconNameForType.get(n.type) || iconNameForType.get(types[0])
        }
      }));

      map.addSource("nodes", { type:"geojson", data: { type:"FeatureCollection", features } });
      map.addLayer({
        id:"nodes",
        type:"symbol",
        source:"nodes",
        layout:{
          "icon-image": ["get","icon"],
          "icon-size": 0.9,
          "icon-allow-overlap": true
        }
      });

      // Fit bounds
      if (features.length){
        const b = new mapboxgl.LngLatBounds();
        features.forEach(f => b.extend(f.geometry.coordinates));
        map.fitBounds(b, {padding:40, maxZoom:6});
      }

      // Filtering and search
      function passesFilters(n){
        const typeOk = (typeSel.value === "All" || n.type === typeSel.value);
        const tagOk  = (tagSel.value === "Any" || n.tags.includes(tagSel.value));
        return typeOk && tagOk;
      }

      function rerender(){
        const filtered = nodes.filter(passesFilters);
        const feats = filtered.map(n => ({
          type: "Feature",
          geometry: { type: "Point", coordinates: [n.lon, n.lat] },
          properties: {
            id: n.id,
            name: n.name,
            type: n.type,
            icon: iconNameForType.get(n.type) || iconNameForType.get(types[0])
          }
        }));
        map.getSource("nodes").setData({ type:"FeatureCollection", features: feats });

        if (feats.length){
          const b = new mapboxgl.LngLatBounds();
          feats.forEach(f => b.extend(f.geometry.coordinates));
          map.fitBounds(b, {padding:40, maxZoom:6});
        }
      }

      typeSel.addEventListener("change", rerender);
      tagSel.addEventListener("change", rerender);
      search.addEventListener("input", () => {
        const q = search.value.toLowerCase().trim();
        const hit = nodes.find(n => n.name.toLowerCase().includes(q));
        if (hit){
          details.innerHTML = `<b>${hit.name}</b> — <i>${hit.type}</i>
${hit.city ? hit.city + ", " : ""}${hit.country || ""}

Tags: ${hit.tags.join(", ") || "—"}
${hit.url ? `<a href="${hit.url}" target="_blank" rel="noopener">Website</a>` : ""}`;
          map.flyTo({center:[hit.lon, hit.lat], zoom:6});
        }
      });
      clearSel.addEventListener("click", ()=>{ details.textContent="(Click a pin to see details)"; search.value=""; rerender(); });

      map.on("click","nodes",(e)=>{
        const f = e.features?.[0];
        if (!f) return;
        const id = f.properties.id;
        const n = nodes.find(x => x.id === id);
        if (!n) return;
        details.innerHTML = `<b>${n.name}</b> — <i>${n.type}</i>
${n.city ? n.city + ", " : ""}${n.country || ""}

Tags: ${n.tags.join(", ") || "—"}
${n.url ? `<a href="${n.url}" target="_blank" rel="noopener">Website</a>` : ""}`;
        map.flyTo({center:[n.lon, n.lat], zoom:6});
      });

      setStatus(`Loaded <b>${nodes.length}</b> nodes.`);
    });
  })();
  </script>
</body>
</html>
