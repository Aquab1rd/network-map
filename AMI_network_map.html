
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Alongside Ministries — Network Map</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    :root { --bg:#0f1115; --panel:#151922; --ink:#e8ebf2; --muted:#9aa3b2; --accent:#3aa0ff; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--ink); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
    .wrap { max-width:1200px; margin:0 auto; padding:20px; }
    h1 { font-size:20px; margin:4px 0 12px; font-weight:700; }
    .grid { display:grid; grid-template-columns: 1fr 380px; gap:16px; }
    .card { background:var(--panel); border:1px solid #202634; border-radius:12px; padding:12px; }
    #map { height:520px; border-radius:10px; overflow:hidden; }
    #net { height:560px; border-radius:10px; overflow:hidden; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .controls label { display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--muted); }
    select, input[type="text"], button { background:#0c0f16; color:var(--ink); border:1px solid #273043; border-radius:8px; padding:8px 10px; min-width:160px;}
    button { cursor:pointer; }
    .legend { display:flex; flex-wrap:wrap; gap:10px 16px; margin:8px 0 4px; }
    .chip { display:inline-flex; align-items:center; gap:6px; font-size:12px; color:var(--muted); }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; outline:1px solid #111; }
    .details { white-space:pre-wrap; }
    a { color:var(--accent); text-decoration:none; }
    a:hover { text-decoration:underline; }
    @media (max-width: 1100px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Alongside Ministries — Interactive Network Map</h1>
    <div class="controls card">
      <label>Type
        <select id="typeFilter"><option>All</option></select>
      </label>
      <label>Tag
        <select id="tagFilter"><option>Any</option></select>
      </label>
      <label>Search
        <input id="searchBox" type="text" placeholder="Type a name…"/>
      </label>
      <label>
        <input id="onlyAlongsider" type="checkbox" /> Only connections of selected alongsider
      </label>
      <button id="clearSel">Clear selection</button>
    </div>

    <div class="legend card" id="legend"></div>

    <div class="grid">
      <div class="card">
        <div id="map"></div>
      </div>
      <div class="card details" id="details">(Click a pin or node to see details)</div>
      <div class="card" style="grid-column: 1 / -1;">
        <div id="net"></div>
      </div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
  <script src="https://unpkg.com/sigma@2.5.0/build/sigma.min.js"></script>

  <script>
  (async function(){
    // === Settings (your links & token) ===
    const NODES_CSV_URL = "https://docs.google.com/spreadsheets/d/1MSwF46BkDjRhOdHd4Pw0ArCVgvdcgDACWvyswFq8XI4/gviz/tq?tqx=out:csv&sheet=Nodes";
    const EDGES_CSV_URL = "https://docs.google.com/spreadsheets/d/1eQrmiVA4wxf6J79SZkyhZb-vEAyX3yxfapen113MSrA/gviz/tq?tqx=out:csv&sheet=Edges";
    const MAPBOX_TOKEN   = "pk.eyJ1IjoiYXF1YWIxcmQiLCJhIjoiY21ndjl5Y2RzMGN2azJsc2J4d3d2N2tyeSJ9.JApvZZEs_kiwNl4Y9-aRaQ";

    // tiny CSV parser (no external deps)
    function parseCSV(text){
      const lines = text.trim().split(/\r?\n/);
      const headers = lines.shift().split(",");
      return lines.map(line => {
        const cols = line.split(","); // simple CSV; works if your fields don't contain commas
        const o = {};
        headers.forEach((h,i)=>o[h]=cols[i]);
        return o;
      });
    }

    // === UI elements ===
    const typeSel = document.getElementById('typeFilter');
    const tagSel  = document.getElementById('tagFilter');
    const search  = document.getElementById('searchBox');
    const onlyAlongsider = document.getElementById('onlyAlongsider');
    const clearSelBtn = document.getElementById('clearSel');
    const legend = document.getElementById('legend');
    const details = document.getElementById('details');

    // === Load data ===
    const nodesText = await (await fetch(NODES_CSV_URL)).text();
    const edgesText = await (await fetch(EDGES_CSV_URL)).text();
    const rawNodes = parseCSV(nodesText);
    const rawEdges = parseCSV(edgesText);

    const nodes = rawNodes
      .filter(d => d.public == null ? true : String(d.public).toUpperCase() === "TRUE")
      .map(d => ({
        id: String(d.id||"").trim(),
        name: (d.name||"").trim(),
        type: (d.type||"").trim(),
        city: (d.city||"").trim(),
        country: (d.country||"").trim(),
        lat: +d.lat,
        lon: +d.lon,
        tags: (d.tags||"").split(/[;,]/).map(t=>t.trim()).filter(Boolean),
        alongsider: (d.alongsider||"").split(/[;,]/).map(a=>a.trim()).filter(Boolean),
        url: d.url||""
      })).filter(n => n.id && Number.isFinite(n.lat) && Number.isFinite(n.lon));

    const nodeById = new Map(nodes.map(n => [n.id, n]));

    let edges = rawEdges
      .filter(d => d.public == null ? true : String(d.public).toUpperCase() === "TRUE")
      .map(e => ({
        source: String(e.source_id||"").trim(),
        target: String(e.target_id||"").trim(),
        relationship: (e.relationship||"").trim(),
        since: e.since||""
      })).filter(e => nodeById.has(e.source) && nodeById.has(e.target) && e.source !== e.target);

    // canonicalize and de-duplicate undirected edges
    edges = (()=>{
      const out = [], seen = new Set();
      for (const e of edges){
        const a = e.source, b = e.target;
        const key = a < b ? a + "|" + b : b + "|" + a;
        if (!seen.has(key)){ seen.add(key); out.push(e); }
      }
      return out;
    })();

    // === derive type + tags ===
    const types = Array.from(new Set(nodes.map(n => n.type))).sort();
    const allTags = Array.from(new Set(nodes.flatMap(n => n.tags))).sort();

    // populate filters
    for (const t of types) typeSel.append(new Option(t, t));
    for (const t of allTags) tagSel.append(new Option(t, t));

    // color scale
    const palettes = [
      "#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f","#edc948","#b07aa1","#ff9da7","#9c755f","#bab0ab",
      "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"
    ];
    const typeColors = new Map(types.map((t,i)=>[t, palettes[i % palettes.length]]));
    function colorFor(n){ return typeColors.get(n.type) || "#999"; }

    // build legend
    for (const t of types) {
      const chip = document.createElement("div"); chip.className="chip";
      const dot = document.createElement("span"); dot.className="dot"; dot.style.background = typeColors.get(t);
      const label = document.createElement("span"); label.textContent = t;
      chip.append(dot,label);
      legend.append(chip);
    }

    // === MAPBOX ===
    mapboxgl.accessToken = MAPBOX_TOKEN;
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v11',
      center: [24,56],
      zoom: 3
    });
    map.addControl(new mapboxgl.NavigationControl());

    function buildGeo(ids){
      return {
        type:"FeatureCollection",
        features: Array.from(ids).map(id => {
          const n = nodeById.get(id);
          return {
            type:"Feature",
            geometry:{ type:"Point", coordinates:[n.lon, n.lat] },
            properties:{ id:n.id, name:n.name, type:n.type, color:colorFor(n) }
          };
        })
      };
    }

    // === SIGMA / Graphology ===
    const G = new graphology.Graph({type:"undirected", multi:false, allowSelfLoops:false});
    for (const n of nodes) {
      G.addNode(n.id, {
        label:n.name, x:Math.random(), y:Math.random(),
        size:6, color:colorFor(n), type:n.type
      });
    }
    for (const e of edges) {
      if (G.hasNode(e.source) && G.hasNode(e.target) && !G.hasEdge(e.source, e.target)) {
        G.addEdge(e.source, e.target, {relationship:e.relationship});
      }
    }
    const renderer = new sigma.Sigma(G, document.getElementById('net'), {
      renderEdgeLabels:false, labelDensity:0.08, labelGridCellSize:60
    });

    // === selection + filters ===
    let selectedId = null;

    function currentFilteredIds(){
      const typeF = typeSel.value;
      const tagF = tagSel.value;
      const base = nodes.filter(n =>
        (typeF === "All" || n.type === typeF) &&
        (tagF === "Any" || n.tags.includes(tagF))
      );

      if (onlyAlongsider.checked && selectedId){
        const seed = nodeById.get(selectedId);
        if (seed && seed.type === "Alongsider"){
          const allowed = new Set(base.map(n=>n.id));
          const keep = new Set([selectedId]);
          for (const e of edges){
            if (e.source === selectedId) keep.add(e.target);
            if (e.target === selectedId) keep.add(e.source);
          }
          return new Set([...keep].filter(id => allowed.has(id)));
        }
      }
      return new Set(base.map(n=>n.id));
    }

    function refreshMap(ids){
      const data = buildGeo(ids);
      if (map.isStyleLoaded() && map.getSource("nodes")){
        map.getSource("nodes").setData(data);
      } else {
        if (!map.getSource("nodes")) map.addSource("nodes", {type:"geojson", data});
        if (!map.getLayer("nodes")){
          map.addLayer({
            id:"nodes", type:"circle", source:"nodes",
            paint:{
              "circle-radius": 6,
              "circle-stroke-width": 1,
              "circle-color": ["get","color"],
              "circle-stroke-color": "#222"
            }
          });
          map.on("click","nodes",(e)=>{
            const f = e.features && e.features[0];
            if (!f) return;
            selectNode(f.properties.id, true);
          });
        }
      }
      // fit
      if (data.features.length){
        const b = new mapboxgl.LngLatBounds();
        data.features.forEach(f => b.extend(f.geometry.coordinates));
        map.fitBounds(b, {padding:40, maxZoom:6});
      }
    }

    function refreshSigma(ids){
      const keep = ids;
      renderer.setSetting("nodeReducer", (n,data)=>{
        return keep.has(n) ? data : {...data, hidden:true};
      });
      renderer.setSetting("edgeReducer", (e,data)=>{
        const ext = G.extremities(e);
        return (keep.has(ext[0]) && keep.has(ext[1])) ? data : {...data, hidden:true};
      });
      renderer.refresh();
      highlightSelection();
    }

    function highlightSelection(){
      const id = selectedId;
      const neighbors = new Set([id]);
      if (id && G.hasNode(id)){
        G.forEachNeighbor(id, nb => neighbors.add(nb));
      }
      renderer.setSetting("nodeReducer", (n,data)=>{
        const hidden = data.hidden;
        if (!id) return data;
        return hidden ? data : (neighbors.has(n) ? data : {...data, color:"#777"});
      });
      renderer.setSetting("edgeReducer", (e,data)=>{
        const ext = G.extremities(e);
        if (!id) return data;
        return (neighbors.has(ext[0]) && neighbors.has(ext[1])) ? data : {...data, color:"#555"};
      });
      renderer.refresh();
    }

    function selectNode(id, fly){
      selectedId = id;
      const n = nodeById.get(id);
      details.innerHTML = n ? (
        `<b>${n.name}</b> — <i>${n.type}</i>\n` +
        `${n.city ? n.city + ", " : ""}${n.country || ""}\n\n` +
        `Tags: ${n.tags.join(", ") || "—"}\n` +
        `${n.url ? `<a href="${n.url}" target="_blank">Website</a>` : ""}\n\n` +
        connectionsText(id)
      ) : "(Click a pin or node to see details)";
      if (fly && n) map.flyTo({center:[n.lon, n.lat], zoom:6});
      highlightSelection();
    }

    function connectionsText(id){
      const linked = edges
        .filter(e => e.source === id || e.target === id)
        .map(e => e.source === id ? e.target : e.source)
        .map(k => nodeById.get(k))
        .filter(Boolean);
      return `Connections (${linked.length})\n` + linked.map(x => `• ${x.name} (${x.type})`).join("\n");
    }

    // search
    search.addEventListener("input", () => {
      const q = search.value.toLowerCase().trim();
      if (!q) return;
      const hit = nodes.find(n => n.name.toLowerCase().includes(q));
      if (hit) selectNode(hit.id, true);
    });

    // clear selection
    clearSelBtn.addEventListener("click", ()=>{
      selectedId = null;
      details.textContent = "(Click a pin or node to see details)";
      highlightSelection();
    });

    // sigma click handler
    renderer.on("clickNode", ({node}) => selectNode(node, true));

    // first render
    const ids = currentFilteredIds();
    refreshMap(ids);
    refreshSigma(ids);

    // filter change handlers
    for (const el of [typeSel, tagSel, onlyAlongsider]){
      el.addEventListener("change", ()=>{
        const ids = currentFilteredIds();
        refreshMap(ids);
        refreshSigma(ids);
      });
    }
  })();
  </script>
</body>
</html>
